# Splinter

Splinter is a service for orchestrating RDF data. 

The solution consists of:
- an Api, endpoints to represent data as RDF and make them accessible to end user applications
- a service layer, business logic to transform datasets and establish relationships between them
- a data layer, communicating with the triplestores used as storage. At the moment only Apache Jena Fuseki triplestores are used.

## Revision train
A key concept in Splinter is the **revision train**. The revision train is a way to structure information common for all revisions of a dataset. As datasets become smaller the definition can be modified to include versions of a dataset.

It is recommended to create **revision trains** using the Splinter Admin tool, but it is possible to do it programmatically by posting its description as RDF to the Api.

Before a revision train is accepted it is being validated using SHAQL.

### Main train
The main train must have a unique name, a valid triplestore where the train's related [records](#records) are stored and a set of [contexts](#contexts). The number of contexts depends on the data the train represent and is further described below.

    @prefix splinter: <https://rdf.equinor.com/ontology/splinter/v1#> 
    
    <https://rdf.equinor.com/revision-train/C277-AS-W-LA-00001> a splinter:RevisionTrain ;
        splinter:name "C277-AS-W-LA-00001" ;
        splinter:tripleStore "wisting" ;
        splinter:trainDataType "mel" ;
        splinter:hasContext <https://rdf.equinor.com/revision-train/C277-AS-W-LA-00001_TieProvenanceContext> ;
        splinter:hasContext <https://rdf.equinor.com/revision-train/C277-AS-W-LA-00001_SpreadsheetDataContext> ;
        splinter:hasContext <https://rdf.equinor.com/revision-train/C277-AS-W-LA-00001_TransformationContext> ;
        splinter:hasContext <https://rdf.equinor.com/revision-train/C277-AS-W-LA-00001_RecordContext/F01> .

<span style="color:green">Note 1:</span> The splinter prefix has been updated. It is now structured as a versioned ontology, so that it can be updated.

<span style="color:green">Note 2:</span> Renamed **splinter:trainType** to **splinter:trainDataType**.

<span style="color:green">Note 3:</span> All context are related to the revision train through the *hasContext* predicate

<span style="color:green">Note 4:</span> Used to have splinter:hasRecord with the IRI of the actual record graph. This gave us two identical entries, one in main and one in the Fuseki storing the named graph, but with different information. The "record" in the main Fuseki is updated to a "record context".

### Contexts
In addition to the main properties a train can have several context with additional metadata. There are 4 context groups in total, namely:
- Provenance Context: additional data about the data stored in the train's records, for instance a project or contract number.
- Data Context: information about the incoming data and how to parse it
- Transformation Context: particulars on how to transform data, like what ontologies to use
- Record Context: particular information about one of the train's records. At the moment, it contains revision information.

Depending on the type of train, it can have maximum one of each of the provenance, data and transformation contexts. The number of record contexts is given by the number of uploaded records and is automatically generated by Splinter. 

#### Provenance Context
The provenance context is information about the data, for instance where they came from, who sent them and what they are. This information varies from data source to data source and gradually a the set of provenance contexts will increase. Below is an example of a **Tie Provenance context** 

    <https://rdf.equinor.com/revision-train/C277-AS-W-LA-00001_TieProvenanceContext> a splinter:TieProvenanceContext ;
        splinter:facilityName "WIST" ;
        splinter:objectName "C277-AS-W-LA-00001" ;
        splinter:contractNumber "4504044842" ;
        splinter:projectCode "L.O537C.001" ;
        splinter:contractorCode "AS" ;
        splinter:documentTitle "MASTER EQUIPMENT LIST - MEL" .

Other provenance contexts that we expect to need are:
- Ontology provenance context
- Shipweight provenance context (might be generalized into FAM provenance context)
- Common lib provenance context

The information in the different provenance contexts will vary - a lot, because the information available from different sources vary.

<span style="color:green">Note 1:</span> Generalized our contexts. The TIE context is a provenance context, so updated the naming to TieProvenanceContext

<span style="color:green">Note 2:</span> Changed from commonlib namespace to splinter namespace. Keep all these terms internal.

#### Data Context
The data context is about the incoming data. It can be on an RDF format, but it is more likely it is something else. Like a spreadsheet or a dialect of XML.
Take the spreadsheet, in this context Splinter needs information about what data to read.

    <https://rdf.equinor.com/revision-train/C277-AS-W-LA-00001_SpreadsheetDataContext> a splinter:SpreadsheetDataContext ;
        splinter:sheetName "MEL" ;
        splinter:headerRow 6 ;
        splinter:dataStartRow 8 ;
        splinter:startColumn 1 ;
        splinter:identityColumn "Tag Number" .

Similar to the provenance context case there will be need for several sub context under data. Also in this case  
<span style="color:green">Note 1:</span> Generalized our contexts. The Spreadsheet context is a data context, so updated the naming to SpreadsheetDataContext

<span style="color:green">Note 2:</span> Put all predicates in the splinter namespace rather than splinter/spreadsheet namespace. Trying to get all Splinter-stuff crammed into one ontology.

#### Transformation Context
The transformation context is currently not in use, but it will be a useful tool to configure transformation. Suggested configurations are:

    <https://rdf.equinor.com/revision-train/C277-AS-P-LA-00016_TransformationContext> a splinter:TransformationContext ;
        splinter:useOntology <https://rdf.equinor.com/main/record/lineOntology/v1> ;
        splinter:useOntology <https://rdf.equinor.com/main/record/lineVocabulary/v1> ;
                splinter:objectPathSegment [c
                splinter:target "Line Number" ;
                splinter:segment "tag" . 
                ] ;
        splinter:objectPathSegment [
                splinter:target "To Line" ;
                splinter:segment "tag" . 
                ] ;
         splinter:objectPathSegment [
                splinter:target "From Line" ;
                splinter:segment "tag" . 
                ] ;
        splinter:detailLevel "basic" . 

Currently the existing versions of a set of vocabularies and ontologies are used based on the incoming data. With **splinter:useOntology** it becomes explicitly stated what version of what ontology the transformation will use. This makes it easy to upgrade to new ontology versions, but, at the same time, provides the full flexibility to use older versions if necessary. 

In some cases, it is considered beneficial to create individuals instead of literals. An example is the line list, where we have relationships like "ToLine" and "FromLine". We would like to be able to create these individuals in a consistent way. This is done by specifying the target predicate and provide an addition the the Iri path. From the transformation context above we'll get

    <https://rdf.equinor.com/wisting/tag/A-20L0074> linelist:ToLine <https://rdf.equinor.com/wisting/tag/A-20L0074> ;

The subject has *tag* in the path due to the "Line Number" target, while the object has it due to the "To Line" target.

The detailLevel predicate specifies the wanted outcome of the transformation:
- raw, returns output as from source without creating individuals
- basic, swaps source predicates with ontology terms and creates individuals according to objectPathSegment
- advanced, creates a more complex model splitting datum, typed values and uom. 

Note that the selected detail levels put requirements on the content of the ontologies used. (Ref. the WIP ontology documentation )

#### Record Context
The record context is additional information about a particular record. It contains, as a minimum, the name of the record and the triplestore where the record is stored. A record is stored as a named graph and the name of the graph and the record is identical. 

Furthermore, the record context can contain revision information. In cases where record:replaces relationships have been established, these will also be available here.

    <https://rdf.equinor.com/revision-train/C277-AS-W-LA-00001_RecordContext/F02> rdf:type  splinter:RecordContext> ;
        splinter:hasRecord <https://rdf.equinor.com/wisting/record/C277-AS-W-LA-00001/F02> ;
        splinter:tripleStore "wisting" ;
        splinter:revisionDate> "2021-12-10" ;
        splinter:revisionName> "F01" ;
        splinter:revisionNumber> "1" ;
        record:replaces <https://rdf.equinor.com/wisting/record/C277-AS-W-LA-00001/F01>

<span style="color:green">Note 4:</span> The namespaces for records have been updated from **https://rdf.equinor.com/graph/wisting/C277-AS-W-LA-00001/F01** to **https://rdf.equinor.com/wisting/record/C277-AS-W-LA-00001/F01**. One one hand, there are more data individuals than records (like for instance tags) on Wisting, while on the other hand there will be records for all fields. The sequence of the path components can therefore be debated, but the focus in the suggestion is on where the data belongs before what they are.

## Records / Named graphs
A record in Splinter follows the record standard in that it is persistent and immutable, but it does not use record concepts like record:isInScope and record:describes. The isInScope information is assumed to be covered by the revision train's provenance context and storing the record as a named graph means that the record:describes relation is covered by being content of the named graph.

<span style="color:green">Note 1:</span> We can either create more proper records and store these in Fuseki, or we could distance us from the record:Record by renaming to NamedGraph.

## Transformation
Splinter has separate "transformation endpoints". These endpoints transform data to an rdf representation and present them as a record:Record.

Even though no data is stored during a transformation, a revision train is still needed. Particularly the various data contexts are needed to properly parse and transform data. Depending on how much *record* information that should be returned the more contexts are needed.

## Validation (future)
As more SHAQL Shapes are made more of the data can be validated. Does all entries in a MEL contain all the required properties. Data is not rejected, but a record context can be appended with validation info. 

## Infrastructure
All Splinter infrastructure is set up using Bicep. This included the API, its backend and all the related Fuseki. Three different environments are spun up by different triggers:
- CI - an environment for testing prior to approving or even creating a PR. Launched on a given Github branch trough Github actions.
- Dev - triggers Github action on merge to main after PR approval
- Prod - triggered by approving and merging the Release.Please PR

## App Developer
Developing applications with data from Splinter is a two-step rocket.

1. Query the **Main** Fuseki for relevant revision trains. We can for instance get all the records for all the revision trains within a given facility. The query below returns contract, triple store where the record is stored, and the record uri itself. The record uri is the named graph on the given triple store. 

<!-- Code block not list -->
    prefix commonlib: <https://rdf.equinor.com/commonlib/tie#>
    prefix splinter: <https://rdf.equinor.com/splinter#>

    SELECT ?contract ?triplestore ?record
    WHERE 
    {
    ?train a splinter:RevisionTrain ;
       splinter:tripleStore ?triplestore ;
       splinter:trainType "mel" ;
       splinter:hasTieContext ?context ;
       splinter:hasRecord ?record .

    ?context commonlib:facilityName "WIST" ;
           commonlib:projectCode "L.O537C.001" ;
           commonlib:contractNumber ?contract . 
    } 

2. The next step is to query **?triplestore** after some data within the given named graphs / records. 

<!-- Another codeblock -->
    SELECT ?g ?s ?p ?o

    FROM NAMED <https://rdf.equinor.com/graph/wisting/C277-AS-W-LA-00001/F01>
    FROM NAMED <https://rdf.equinor.com/graph/wisting/C277-AS-W-LA-00001/F02>
    FROM NAMED <https://rdf.equinor.com/graph/wisting/C277-AS-W-LA-00001/F03>

    WHERE 
    {
        GRAPH ?g 
        { 
            ?s ?p ?o .
        } 
    }
    LIMIT 100

<span style="color:green">Note 1:</span> Named graph as used in RDF triplestores and records should be defined somewhere in this document.

<span style="color:green">Note 2:</span> These queries work in the current dev environment, but must be updated when (and if) the suggested changes in this description survives.

## Splinter Developer
For information on how to run Splinter locally see [LOCAL_DEVELOPMENT.md](LOCAL_DEVELOPMENT.md)
